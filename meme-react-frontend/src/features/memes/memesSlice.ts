import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit';
import {fetchMemes} from './memesAPI';
import {RootState} from "../../app/store";

export interface IMeme {
    uuid: string;
    name: string;
    enabled: boolean;
    text_fields: ITextField[];
    thumbnail_path: string;
    high_res_path: string;
}

export interface ITextField {
    value?: string;
    order: number;
    width: number;
    height: number;
    distance_to_left: number;
    distance_to_bottom: number;
    rotation: number;
    text_style: string;
}

export interface UpdateTextfieldEvent {
    textFieldIndex: number,
    value: string
}

export interface MemesState {
    baseMemes: IMeme[];
    status: 'idle' | 'loading' | 'failed';
    selectedMemeIndex: number;
}

const initialState: MemesState = {
    baseMemes: [],
    status: 'idle',
    selectedMemeIndex: 0
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchMemesFromAPI = createAsyncThunk(
    'memes/fetchMemes',
    async () => {
        const response = await fetchMemes();
        // The value we return becomes the `fulfilled` action payload
        return response.data;
    }
);

export const memesSlice = createSlice({
    name: 'memes',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        chooseMeme: (state, action: PayloadAction<number>) => {
            // Redux Toolkit allows us to write "mutating" logic in reducers. It
            // doesn't actually mutate the state because it uses the Immer library,
            // which detects changes to a "draft state" and produces a brand new
            // immutable state based off those changes
            const newIndex = action.payload;
            if (newIndex < state.baseMemes.length && state.baseMemes[newIndex].enabled) {
                state.selectedMemeIndex = newIndex;
            }
        },
        updateTextFieldValue: (state, action: PayloadAction<UpdateTextfieldEvent>) => {
            // Redux Toolkit allows us to write "mutating" logic in reducers. It
            // doesn't actually mutate the state because it uses the Immer library,
            // which detects changes to a "draft state" and produces a brand new
            // immutable state based off those changes
            state.baseMemes[state.selectedMemeIndex].text_fields[action.payload.textFieldIndex].value = action.payload.value
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(fetchMemesFromAPI.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(fetchMemesFromAPI.fulfilled, (state, action) => {
                state.status = 'idle';
                state.baseMemes = action.payload;
            });
    },
});

export const {chooseMeme, updateTextFieldValue} = memesSlice.actions;

export const selectMemes = (state: RootState) => state.memes.baseMemes;
export const selectChosenMeme = (state: RootState) => state.memes.baseMemes[state.memes.selectedMemeIndex];

export default memesSlice.reducer;
